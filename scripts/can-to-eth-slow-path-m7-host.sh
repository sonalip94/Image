#!/usr/bin/env bash
# SPDX-License-Identifier: BSD-3-Clause
#
# Copyright 2021-2022 NXP
#
# This script implements the host machine logic for the CAN to Ethernet
# forwarding slow path through M7 AUTOSAR COM stack scenario.
#
# The host is implied to have 1 network interface available in order to handle 
# the UDP segments injected via canperf.sh by the board machine. 
#
# The test metrics are available under a report generated by the python script
# and canperf.sh.
# This script will take care of setting up the ethernet interface and pass the
# proper arguments to canperf.sh

# shellcheck source=docker/scripts/eth-common-host.sh
source "${BASH_SOURCE[0]%/*}/eth-common-host.sh"

duration=30
payload_size=64
gap=1
uart_dev="/dev/ttyUSB0"
can_tx_interface="can0"
can_id=32
udp_port=1024
can_to_eth_log="can2eth_slow_path.log"

usage() {
    echo -e "Usage: sudo ./$(basename "$0") [option] <eth_interface> <can_interface> 
Create namespace for eth interface and run can_to_eth_slow_path_m7.py to measure throughput between <can_interface> and <eth_interface>.\n
OPTIONS:
        -l <seconds>           specify the duration of the test (default is 30 seconds)
        -s <bytes>             CAN frame payload size (default is 64 bytes)
        -g <miliseconds>       The gap between two CAN frames (default is 1 ms)
        -u <tty_device>        UART device connected to target (default is /dev/ttyUSB0)
        -h                     help"
}

delete_network_ns() {
    echo -e "\nDeleting network namespace..."
    ip netns exec nw_ns0 ip link set "${eth_interface}" netns 1
    ip netns delete nw_ns0
}

clean_host() {
    # Clear the trap handler to avoid infinite loops.
    set +Ee
    trap - ERR

    delete_network_ns
}

set_trap() {
    # Set trap handler for INT signal given via the Ctrl-C combination.
    trap "clean_host ; exit 130" INT

    trap 'echo "An error occurred in file $0, at line ${BASH_LINENO[0]}" ; clean_host ; exit ${GENERAL_ERR}' ERR
}

# Validate the interfaces received as arguments.
# the 1st argument is the ethernet interface
# the 2nd argument is the can interface
check_interface_args() {
    local eth="$1"
    local can="$2"

    if [ ! -e /sys/class/net/"${eth}" ]; then
        echo -e "Wrong ethernet interface, expected member of the list:"
        ls /sys/class/net
        usage
        exit "${INVALID_USER_ARGUMENT_ERR}"
    fi
    if [ "$can" != "can0" ] && [ "$can" != "can1" ]; then
        echo -e "Wrong CAN interface, expecting can0 or can1"
        usage
        exit "${INVALID_USER_ARGUMENT_ERR}"
    fi
}

check_input() {
    # Check root privileges.
    if [ "${EUID}" -ne 0 ]; then
        echo "Please run as root!"
        usage
        exit "${PRIVILEGE_ERR}"
    fi

    if [ $# -eq 0 ]; then
        echo -e "Please input parameters!\n"
        usage
        exit "${INVALID_USER_ARGUMENT_ERR}"
    fi

    while [ $# -gt 0 ]; do
        case "$1" in
            -h)
                usage
                exit
                ;;
            -l)
                shift
                duration=$1
                if [[ ! ${duration} =~ ${integer_regex} ]]; then
                    echo "Invalid test duration! -l argument must be a positive integer."
                    usage
                    exit ${INVALID_USER_ARGUMENT_ERR}
                fi
                ;;
            -s)
                shift
                payload_size=$1
                if [[ ! ${payload_size} =~ ${integer_regex} ]]; then
                    echo "Invalid payload size type!"
                    usage
                    exit ${INVALID_USER_ARGUMENT_ERR}
                fi
                ;;
            -u)
                shift
                uart_dev=$1
                if [ ! -c "${uart_dev}" ]; then
                    echo "Wrong tty device!"
                    usage
                    exit ${INVALID_USER_ARGUMENT_ERR}
                fi
                ;;
            -g)
                shift
                gap=$1
                if [[ ! ${gap} =~ ${integer_regex} ]]; then
                    echo "Frame gap must be a positive integer number!"
                    usage
                    exit ${INVALID_USER_ARGUMENT_ERR}
                fi
                ;;
            *)
                if [ $# -eq 2 ]; then
                    can_tx_interface=$1
                    eth_interface=$2
                    check_interface_args "${eth_interface}" "${can_tx_interface}"
                    shift 1
                else
                    echo "Wrong input option!"
                    usage
                    exit ${INVALID_USER_ARGUMENT_ERR}
                fi
                ;;
        esac; shift;
    done
}

setup_host() {
    echo "Creating nw_ns0 network namespace..."
    if [ -e /var/run/netns/nw_ns0 ]; then
        echo "nw_ns0 network space already created!"
    else
        ip netns add nw_ns0
    fi

    # Add physical interfaces to the corresponding network namespace.
    echo "Adding ${eth_interface} interface to nw_ns0..."
    ip link set "${eth_interface}" netns nw_ns0

    # Bring interfaces up.
    ip netns exec nw_ns0 ip link set dev "${eth_interface}" up

    ping_return="${GENERAL_ERR}"

    echo "Checking connection to the device"
    _set_ip_for_netns "nw_ns0" "${eth_interface}" "169.254.12.10"
    ip netns exec nw_ns0 ping -c 4 "169.254.12.12" && ping_return=$?
    if [ ${ping_return} -ne 0 ]; then
        echo "Ethernet connection with board does not work"
        clean_host
        exit ${NET_ERR}
    fi
    # Default configuration is that we're sending on CAN0. If otherwise
    # redo the configuration
    if [ "${can_tx_interface}" == "can1" ]; then
        can_id=34
        udp_port=1026
    fi
}

setup_target() {
    # Set TTY device baudrate.
    stty -F "${uart_dev}" 115200

    # Reset PFE2 to default mode (FLEXIBLE_ROUTER)
    echo "libfci_cli phyif-update --i emac2 --mode FLEXIBLE_ROUTER --enable --promisc OFF" > "${uart_dev}"
    # Set the interface up
    echo "ip link set pfe2 up" > "${uart_dev}"
}

run_test() {
    # Start the python script which receives the ethernet packets
    ip netns exec nw_ns0 python3 can_to_eth_slow_path_m7.py -l "${duration}" -log "${nw1_log}" -s "${payload_size}" -host-tcpip-port "${udp_port}"&
    pid=$!
    # Wait for py to be ready to receive packets
    sleep 1
    # Start canperf on the board
    echo "/home/root/can-gw/canperf.sh -i ${can_id} -t ${can_tx_interface} -s ${payload_size} -g ${gap} -l ${duration}  > /tmp/${can_to_eth_log}" > "${uart_dev}"
    # Wait for py script to finish. It should indicate that test is done
    wait $pid
}   

display_results() {
    # Get log from the target
    _copy_file_over_serial "/tmp/${can_to_eth_log}" "${nw0_log}"

    # Get transmit and receive information from log files
    tx_frames=$(sed -n -r 's/^Tx frames:\s+(\w+)/\1/p' "${nw0_log}")
    tx_bytes=$(sed -n -r 's/^Tx data transfer:\s+([0-9]+)\s+bytes/\1/p' "${nw0_log}")
    m7_0_core_load=$(sed -n -r 's/^M7_0 core load:\s+([0-9]+)/\1/p' "${nw0_log}")
    m7_1_core_load=$(sed -n -r 's/^M7_1 core load:\s+([0-9]+)/\1/p' "${nw0_log}")
    rx_frames=$(sed -n -r 's/^Rx frames:\s+(\w+)/\1/p' "${nw1_log}")
    rx_bytes=$(sed -n -r 's/^Rx data transfer:\s+([0-9]+)\s+bytes/\1/p' "${nw1_log}")
    frames_lost=$((tx_frames - rx_frames))
    # Clear the log files
    rm -f "${nw1_log}" "${nw0_log}"

    echo "Transmit CAN id         : $(printf %x "${can_id}")"
    echo "CAN transmit interface  : ${can_tx_interface}"
    echo "#############################################################"
    echo "Tx frames:                ${tx_frames}"
    echo "Rx frames:                ${rx_frames}"
    echo "Tx data transfer:         ${tx_bytes} bytes"
    echo "Rx data transfer:         ${rx_bytes} bytes"
    echo "Tx frames/s:              $((tx_frames / duration))"
    echo "Rx frames/s:              $((rx_frames / duration))"
    echo "Tx throughput:            $((tx_bytes * 8 / ((duration * 1000)))) Kbit/s"
    echo "Rx throughput:            $((rx_bytes * 8 / ((duration * 1000)))) Kbit/s"
    echo "Lost frames:              ${frames_lost}"
    echo "Lost frames (%):          $((frames_lost * 100 / tx_frames)).$(((frames_lost * 100 - (frames_lost * 100 / tx_frames) * tx_frames) * 100 / tx_frames))%"
    echo "M7_0 core load:           ${m7_0_core_load}"
    echo "M7_1 core load:           ${m7_1_core_load}"
    echo "#############################################################"
}

set_trap
check_input "$@"
setup_target
setup_host
run_test
display_results
clean_host

